import Sharp from 'sharp';
import defu2 from 'defu';
import imageMeta from 'image-meta';
import { hasProtocol, parseURL, normalizeURL, parseQuery, withoutLeadingSlash, decode } from 'ufo';
import { resolve } from 'path';
import isValidPath from 'is-valid-path';
import { stat, readFile } from 'fs-extra';
import destr2 from 'destr';
import http2 from 'http';
import https2 from 'https';
import fetch from 'node-fetch';
import getEtag from 'etag';
import xss2 from 'xss';

function getEnv(name, defaultValue) {
  var _a;
  return (_a = destr2(process.env[name])) != null ? _a : defaultValue;
}
function cachedPromise(fn) {
  let p;
  return (...args) => {
    if (p) {
      return p;
    }
    p = Promise.resolve(fn(...args));
    return p;
  };
}
class IPXError extends Error {
}
function createError(message, statusCode) {
  const err = new IPXError(message);
  err.statusMessage = message;
  err.statusCode = statusCode;
  return err;
}

const createFilesystemSource = (options) => {
  const rootDir = resolve(options.dir);
  return async (id) => {
    const fsPath = resolve(rootDir, id);
    if (!isValidPath(id) || id.includes("..") || !fsPath.startsWith(rootDir)) {
      throw createError("Forbidden path:" + id, 403);
    }
    let stats;
    try {
      stats = await stat(fsPath);
    } catch (err) {
      if (err.code === "ENOENT") {
        throw createError("File not found: " + fsPath, 404);
      } else {
        throw createError("File access error for " + fsPath + ":" + err.code, 500);
      }
    }
    return {
      mtime: stats.mtime,
      maxAge: options.maxAge || 300,
      getData: cachedPromise(() => readFile(fsPath))
    };
  };
};

const createHTTPSource = (options) => {
  const httpsAgent = new https2.Agent({keepAlive: true});
  const httpAgent = new http2.Agent({keepAlive: true});
  let domains = options.domains || [];
  if (typeof domains === "string") {
    domains = domains.split(",").map((s) => s.trim());
  }
  return async (id) => {
    if (!domains.find((base) => id.startsWith(base))) {
      throw createError("Forbidden URL:" + id, 403);
    }
    const response = await fetch(id, {
      agent: id.startsWith("https") ? httpsAgent : httpAgent
    });
    if (!response.ok) {
      throw createError(response.statusText || "fetch error", response.status || 500);
    }
    let maxAge = options.maxAge || 300;
    const _cacheControl = response.headers.get("cache-control");
    if (_cacheControl) {
      const m = _cacheControl.match(/max-age=(\d+)/);
      if (m && m[1]) {
        maxAge = parseInt(m[1]);
      }
    }
    let mtime;
    const _lastModified = response.headers.get("last-modified");
    if (_lastModified) {
      mtime = new Date(_lastModified);
    }
    return {
      mtime,
      maxAge,
      getData: cachedPromise(() => response.buffer())
    };
  };
};

function VArg(arg) {
  return destr2(arg);
}
function parseArgs(args, mappers) {
  const vargs = args.split("_");
  return mappers.map((v, i) => v(vargs[i]));
}

const quality = {
  args: [VArg],
  apply: (context, _pipe, quality2) => {
    context.quality = quality2;
  }
};
const fit = {
  args: [VArg],
  apply: (context, _pipe, fit2) => {
    context.fit = fit2;
  }
};
const HEX_RE = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
const SHORTHEX_RE = /^([a-f\d])([a-f\d])([a-f\d])$/i;
const background = {
  args: [VArg],
  apply: (context, _pipe, background2) => {
    if (!background2.startsWith("#") && (HEX_RE.test(background2) || SHORTHEX_RE.test(background2))) {
      background2 = "#" + background2;
    }
    context.background = background2;
  }
};
const width = {
  args: [VArg],
  apply: (_context, pipe, width2) => {
    return pipe.resize(width2, null);
  }
};
const height = {
  args: [VArg],
  apply: (_context, pipe, height2) => {
    return pipe.resize(null, height2);
  }
};
const resize = {
  args: [VArg, VArg, VArg],
  apply: (context, pipe, width2, height2) => {
    return pipe.resize(width2, height2, {
      fit: context.fit,
      background: context.background
    });
  }
};
const trim = {
  args: [VArg],
  apply: (_context, pipe, threshold2) => {
    return pipe.trim(threshold2);
  }
};
const extend = {
  args: [VArg, VArg, VArg, VArg],
  apply: (context, pipe, top, right, bottom, left) => {
    return pipe.extend({
      top,
      left,
      bottom,
      right,
      background: context.background
    });
  }
};
const extract = {
  args: [VArg, VArg, VArg, VArg],
  apply: (context, pipe, top, right, bottom, left) => {
    return pipe.extend({
      top,
      left,
      bottom,
      right,
      background: context.background
    });
  }
};
const rotate = {
  args: [VArg],
  apply: (_context, pipe, angel) => {
    return pipe.rotate(angel);
  }
};
const flip = {
  args: [],
  apply: (_context, pipe) => {
    return pipe.flip();
  }
};
const flop = {
  args: [],
  apply: (_context, pipe) => {
    return pipe.flop();
  }
};
const sharpen = {
  args: [VArg, VArg, VArg],
  apply: (_context, pipe, sigma, flat, jagged) => {
    return pipe.sharpen(sigma, flat, jagged);
  }
};
const median = {
  args: [VArg, VArg, VArg],
  apply: (_context, pipe, size) => {
    return pipe.median(size);
  }
};
const blur = {
  args: [VArg, VArg, VArg],
  apply: (_context, pipe) => {
    return pipe.blur();
  }
};
const flatten = {
  args: [VArg, VArg, VArg],
  apply: (context, pipe) => {
    return pipe.flatten({
      background: context.background
    });
  }
};
const gamma = {
  args: [VArg, VArg, VArg],
  apply: (_context, pipe, gamma2, gammaOut) => {
    return pipe.gamma(gamma2, gammaOut);
  }
};
const negate = {
  args: [VArg, VArg, VArg],
  apply: (_context, pipe) => {
    return pipe.negate();
  }
};
const normalize = {
  args: [VArg, VArg, VArg],
  apply: (_context, pipe) => {
    return pipe.normalize();
  }
};
const threshold = {
  args: [VArg],
  apply: (_context, pipe, threshold2) => {
    return pipe.threshold(threshold2);
  }
};
const modulate = {
  args: [VArg],
  apply: (_context, pipe, brightness, saturation, hue) => {
    return pipe.modulate({
      brightness,
      saturation,
      hue
    });
  }
};
const tint = {
  args: [VArg],
  apply: (_context, pipe, rgb) => {
    return pipe.tint(rgb);
  }
};
const grayscale = {
  args: [VArg],
  apply: (_context, pipe) => {
    return pipe.grayscale();
  }
};
const crop = extract;
const q = quality;
const b = background;
const w = width;
const h = height;
const s = resize;

var Handlers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  quality: quality,
  fit: fit,
  background: background,
  width: width,
  height: height,
  resize: resize,
  trim: trim,
  extend: extend,
  extract: extract,
  rotate: rotate,
  flip: flip,
  flop: flop,
  sharpen: sharpen,
  median: median,
  blur: blur,
  flatten: flatten,
  gamma: gamma,
  negate: negate,
  normalize: normalize,
  threshold: threshold,
  modulate: modulate,
  tint: tint,
  grayscale: grayscale,
  crop: crop,
  q: q,
  b: b,
  w: w,
  h: h,
  s: s
});

function applyHandler(ctx, pipe, key, val) {
  const handler = Handlers[key];
  if (!handler) {
    return;
  }
  const args = handler.args && parseArgs(val, handler.args);
  return handler.apply(ctx, pipe, ...args);
}

const SUPPORTED_FORMATS = ["jpeg", "png", "webp", "avif", "tiff"];
function createIPX(userOptions) {
  const defaults = {
    dir: getEnv("IPX_DIR", "."),
    domains: getEnv("IPX_DOMAINS", []),
    sharp: {}
  };
  const options = defu2(userOptions, defaults);
  const ctx = {
    sources: {}
  };
  if (options.dir) {
    ctx.sources.filesystem = createFilesystemSource({
      dir: options.dir
    });
  }
  if (options.domains) {
    ctx.sources.http = createHTTPSource({
      domains: options.domains
    });
  }
  return function ipx(id, inputOpts = {}) {
    if (!id) {
      throw createError("resource id is missing", 400);
    }
    const modifiers = inputOpts.modifiers || {};
    const getSrc = cachedPromise(() => {
      const source = inputOpts.source || hasProtocol(id) ? "http" : "filesystem";
      if (!ctx.sources[source]) {
        throw createError("Unknown source: " + source, 400);
      }
      return ctx.sources[source](id);
    });
    const getData = cachedPromise(async () => {
      const src = await getSrc();
      const data = await src.getData();
      const meta = imageMeta(data);
      const mFormat = modifiers.f || modifiers.format;
      let format = mFormat || meta.type;
      if (format === "jpg") {
        format = "jpeg";
      }
      if (meta.type === "svg" && !mFormat) {
        return {
          data,
          format: "svg",
          meta
        };
      }
      let sharp2 = Sharp(data);
      Object.assign(sharp2.options, options.sharp);
      const modifierCtx = {};
      for (const key in inputOpts.modifiers) {
        sharp2 = applyHandler(modifierCtx, sharp2, key, inputOpts.modifiers[key]) || sharp2;
      }
      if (SUPPORTED_FORMATS.includes(format)) {
        sharp2 = sharp2.toFormat(format, {
          quality: modifierCtx.quality,
          progressive: format === "jpeg"
        });
      }
      const newData = await sharp2.toBuffer();
      return {
        data: newData,
        format,
        meta
      };
    });
    return {
      src: getSrc,
      data: getData
    };
  };
}

async function handleRequest(req, res, ipx2) {
  const url = parseURL(normalizeURL(req.url));
  const params = parseQuery(url.search);
  const id = withoutLeadingSlash(decode(url.pathname || params.id));
  const modifiers = Object.create(null);
  for (const pKey in params) {
    if (pKey === "source" || pKey === "id") {
      continue;
    }
    modifiers[pKey] = params[pKey];
  }
  const img = ipx2(id, {
    modifiers,
    source: params.source
  });
  const src = await img.src();
  if (src.mtime) {
    if (req.headers["if-modified-since"]) {
      if (new Date(req.headers["if-modified-since"]) >= src.mtime) {
        res.statusCode = 304;
        return res.end();
      }
    }
    res.setHeader("Last-Modified", +src.mtime);
  }
  if (src.maxAge !== void 0) {
    res.setHeader("Cache-Control", `max-age=${+src.maxAge}, public, s-maxage=${+src.maxAge}`);
  }
  const {data, format} = await img.data();
  const etag2 = getEtag(data);
  res.setHeader("ETag", etag2);
  if (etag2 && req.headers["if-none-match"] === etag2) {
    res.statusCode = 304;
    return res.end();
  }
  if (format) {
    res.setHeader("Content-Type", "image/" + format);
  }
  res.end(data);
}
function createIPXMiddleware(ipx2) {
  return function IPXMiddleware(req, res) {
    handleRequest(req, res, ipx2).catch((err) => {
      const statusCode = parseInt(err.statusCode) || 500;
      const statusMessage = err.statusMessage ? xss2(err.statusMessage) : `IPX Error (${statusCode})`;
      if (process.env.NODE_ENV !== "production" && statusCode === 500) {
        console.error(err);
      }
      res.statusCode = statusCode;
      res.statusMessage = statusMessage;
      return res.end(statusMessage);
    });
  };
}

export { createIPX, createIPXMiddleware };
